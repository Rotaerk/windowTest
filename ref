#!/usr/bin/env bash
set -eu

invokedPath=$0
refsDir="${PWD}/refs"
refSrcsSubdir="src"

main() {
  usageText="Usage: $invokedPath <flags> <command> [<command specific args>]

Flags:
--help - display this message
--path <path> - specify the <path> where references are stored

Commands:
add - add a new reference
modify - modify an existing reference
update - update an existing reference to the latest version
src - set of commands manipulating local copy of source code for a reference
"

  while (( "$#" )); do

    case "$1" in
      --help) usage;;
      --path)
        shift;

        if (( $# == 0 )); then
          errorUsage 'No path specified.'
        fi

        refsDir="$1"
        ;;

      add) shift; add "$@"; return;;
      modify) shift; modify "$@"; return;;
      update) shift; update "$@"; return;;
      src) shift; src "$@"; return;;

      *) errorUsage "Unrecognized argument: $1";;
    esac

    shift;

  done

  errorUsage 'No command provided.'
}

add() {
  usageText="Usage: $invokedPath add <flags> <scheme> [<scheme-specific args>]

Flags:
--help - display this message
--name <name> - specify the <name> of the new reference; the default name is determined in a scheme-specific manner.
--force | -f - if a reference already exists with the new reference's name, overwrite it

Arguments:
<scheme> - the scheme of the reference to create.  Valid options are below.
<scheme-specific args> - the remaining arguments depend on the reference's scheme; omit to see more details

Schemes:
github - reference points to a revision in a github repo
hackage - reference points to a package version on hackage
"
  shouldGuardExistingRef=true

  while (( "$#" )); do

    case "$1" in
      --help) usage;;
      --name)
        shift;

        if (( $# == 0 )); then
          errorUsage 'No name specified.'
        fi

        setRefName "$1"
        ;;
      --force|-f) shouldGuardExistingRef=false;;

      github) shift; addGithub "$@"; return;;
      hackage) shift; addHackage "$@"; return;;

      *) errorUsage "Unrecognized argument: $1";;
    esac

    shift;

  done

  errorUsage 'No scheme provided for add.'
}

addGithub() {
  usageText="Usage: $invokedPath add github <flags> <owner> <repo> (commit <ID> | branch <name>)

Flags:
--help - display this message

Arguments:
<owner> - the name of the github profile that owns the repository
<repo> - the name of the repository to reference
commit <ID> - indicates that the reference should point to the commit with the specified ID.
branch <name> - indicates that the reference should point to the current commit of the GitHub branch with the specified name.  Name can be HEAD.
"

  if [ "${1+x}" == "--help" ]; then
    usage
  fi

  if (( $# < 3 )); then
    errorUsage 'Not enough arguments provided.'
  fi

  local owner="$1"
  local repo="$2"

  shift 2

  if [ -z ${refName+x} ]; then
    setRefName "$repo"
  fi

  guardExistingRef

  local githubUrl="https://github.com/$owner/$repo"

  case "$1" in
    commit)
      shift;

      if (( $# == 0 )); then
        errorUsage 'No commit ID specified.'
      fi

      local commitId="$1"
      ;;

    branch)
      shift;

      if (( $# == 0 )); then
        errorUsage 'No branch name specified.'
      fi

      local branchName="$1"

      local commitIds=( $(git ls-remote "$githubUrl" "$branchName" | sed -n 's/^\(\S*\).*$/\1/p') )

      case ${#commitIds[*]} in
        0) error "'$branchName' branch not found in GitHub repository.";;
        1) local commitId="${commitIds[0]}";;
        *) error "Unexpected: More than one '$branchName' branch found in GitHub repository.";;
      esac
      ;;

    *) errorUsage "Unrecognized argument: $1";;
  esac

  nixPrefetchScripts="$(nix-build --no-out-link -E '(import <nixpkgs> {}).nix-prefetch-scripts')"

  local sha256="$($nixPrefetchScripts/bin/nix-prefetch-zip --hash-type sha256 "$githubUrl/archive/$commitId.tar.gz")"

  if [ -z $sha256 ]; then
    error "Failed to obtain a hash for commit $commitId from GitHub."
  fi

  ensureDirExists "$refsDir"

  cat <<EOF > $refFilePath
{
  scheme = "github";
  owner = "$owner";
  repo = "$repo";
  rev = "$commitId";
  sha256 = "$sha256";
}
EOF

  echo "Reference file '$refFilePath' now refers to $githubUrl commit $commitId."
}

addHackage() {
  usageText="Usage: $invokedPath add hackage <flags> <name> <version>

Flags:
--help - display this message

Arguments:
<name> - name of the Hackage package to reference
<version> - version of the Hackage package to reference
"

  if [ "${1+x}" == "--help" ]; then
    usage
  fi

  if (( $# < 2 )); then
    errorUsage 'Not enough arguments provided.'
  fi

  local packageName="$1"
  local packageVersion="$2"
  local packageId="$packageName-$packageVersion"

  if [ -z ${refName+x} ]; then
    setRefName "$packageName"
  fi

  guardExistingRef

  local sha256="$(nix-prefetch-url mirror://hackage/"$packageId".tar.gz)"

  if [ -z $sha256 ]; then
    error "Failed to obtain a hash for $packageId from hackage."
  fi

  ensureDirExists "$refsDir"

  cat <<EOF > $refFilePath
{
  scheme = "hackage";
  name = "$packageName";
  version = "$packageVersion";
  sha256 = "$sha256";
}
EOF

  echo "Reference file '$refFilePath' now refers to the hackage package $packageId."
}

modify() {
  usageText="Usage: $invokedPath modify <flags> <refname> [<scheme-specific args>]

Flags:
--help - display this message

Arguments:
<refname> - name of the reference to modify
<scheme-specific args> - the remaining arguments depend on the reference's scheme; omit to see more details
"

  while (( "$#" )); do

    case "$1" in
      --help) usage;;
      *)
        setRefName "$1"
        shift;

        local refScheme="$(readRef "$refName" scheme)"

        case "$refScheme" in
          github) modifyGithub "$@";;
          hackage) modifyHackage "$@";;
          *) error "The modify command does not support this reference's scheme: $refScheme.";;
        esac

        return
      ;;
    esac

    shift;

  done

  errorUsage 'No refname specified'
}

modifyGithub() {
  usageText="Usage: $invokedPath modify $refName (commit <ID> | branch <name>)

Arguments:
commit <ID> - indicates that the reference should be modified to point to the commit with the specified ID.
branch <name> - indicates that the reference should be modified to point to the current commit of the GitHub branch with the specified name.  Name can be HEAD.
"
  if (( $# < 1 )); then
    errorUsage 'Not enough arguments provided.'
  fi

  owner="$(readRef "$refName" owner)"
  repo="$(readRef "$refName" repo)"

  case "$1" in
    commit)
      shift

      if (( $# == 0 )); then
        errorUsage 'No commit ID specified.'
      fi

      add -f github "$owner" "$repo" commit "$1"
      ;;
    branch)
      shift

      if (( $# == 0 )); then
        errorUsage 'No branch name specified.'
      fi

      add -f github "$owner" "$repo" branch "$1"
      ;;
    *) errorUsage "Unrecognized argument: $1";;
  esac
}

modifyHackage() {
  usageText="Usage: $invokedPath modify $refName <version>

Arguments:
<version> - new version of the Hackage package to reference
"

  if (( $# < 1 )); then
    errorUsage 'Not enough arguments provided.'
  fi

  add -f hackage "$(readRef "$refName" name)" "$1"
}

update() {
  usageText="Usage: $invokedPath update [<flags>] <refname> [<scheme-specific args>]

Flags:
--help - display this message

Arguments:
<refname> - name of the reference to update
<scheme-specific args> - the remaining arguments depend on the reference's scheme; omit to see more details
"

  while (( "$#" )); do

    case "$1" in
      --help) usage;;
      *)
        setRefName "$1"
        shift;

        local refScheme="$(readRef "$refName" scheme)"

        case "$refScheme" in
          github) updateGithub "$@";;
          *) error "The update command does not support this reference's scheme: $refScheme.";;
        esac

        return
      ;;
    esac

    shift;

  done

  errorUsage 'No refname specified'
  
}

updateGithub() {
  usageText="Usage: $invokedPath update $refName [<flags>] [<branch>]

Flags:
--help - display this message

Arguments:
<branch> - the branch to update the reference to the latest revision of. If omitted, get the list of descendant branches.  If only one exists, update to that branch.  Otherwise, display a list of the descendant branches.
"
  while (( "$#" )); do

    case "$1" in
      --help) usage;;
      --*) errorUsage "Unrecognized flag: $1";;

      *) local branchName="$1"; break;;
    esac

    shift

  done

  if [ -z ${branchName+x} ]; then

    if dirIsEmpty "$refSrcDir"; then
      srcGithubClone
    fi

    gitCmd() { git -C "$refSrcDir" "$@"; }

    gitCmd fetch

    local descendantsPlusHead=$(gitCmd branch -r --contains "$(readRef "$refName" rev)" | sed -n s_origin/__gp)
    local descendants=$(echo "$descendantsPlusHead" | grep -v 'HEAD ->')
    local numDescendants=$(echo "$descendants" | wc -l)

    case "$numDescendants" in
      1)
        modifyGithub branch "$descendants"
        echo "Updated to the latest revision of the only descendant branch, '$descendants'."
        ;;
      0) echo "Found no descendants of referenced revision.";;
      *) 
        echo "Found more than one descendant of referenced revision:"
        echo "$descendantsPlusHead"
        ;;
    esac

  else

    modifyGithub branch "$branchName"
    echo "Updated to the latest revision of the '$branchName' branch."

  fi
}

src() {
  usageText="Usage: $invokedPath src [<flags>] <refname> [<scheme-specific args>]

Flags:
--help - display this message

Arguments:
<refname> - name of the reference for which the local source will be manipulated
<scheme-specific args> - the remaining arguments depend on the reference's scheme; omit to see more details
"

  while (( "$#" )); do

    case "$1" in
      --help) usage;;
      *)
        setRefName "$1"
        shift;

        local refScheme="$(readRef "$refName" scheme)"

        case "$refScheme" in
          github) srcGithub "$@";;
          *) error "The src command does not support this reference's scheme: $refScheme.";;
        esac

        return
      ;;
    esac

    shift;

  done

  errorUsage 'No refname specified'
}

srcGithub() {
  usageText="Usage: $invokedPath src $refName [<flags>] <command> [<command-specific args>]

Flags:
--help - display this message

Commands:
clone - clones the github repository locally
"

  while (( "$#" )); do

    case "$1" in
      --help) usage;;

      clone) shift; srcGithubClone "$@"; return;;

      *) errorUsage "Unrecognized argument: $1";;
    esac

    shift;

  done

  errorUsage 'No command provided.'

}

srcGithubClone() {
  ensureDirExists "$refsDir/$refSrcsSubdir"

  if dirHasFiles "$refSrcDir"; then
    error "The reference source directory, '$refSrcDir', already contains files.  Aborting."
  fi

  git clone "$(readRef "$refName" '"https://github.com/${owner}/${repo}"')" "$refSrcDir"
}

usage () {
  echo "$usageText"
  exit 0
}

error () {
  echo >&2 "$1"
  exit 1
}

errorUsage () {
  echo >&2 "$1"$'\n'"$usageText"
  exit 1
}

setRefName () {
  refName="$1"
  if [ -z "$refName" ]; then
    errorUsage "An empty reference name was specified."
  fi
  refFilePath="$refsDir/$refName"
  refSrcDir="$refsDir/$refSrcsSubdir/$refName"
}

guardExistingRef() {
  if $shouldGuardExistingRef && [ -f "$refFilePath" ]; then
    error "A reference with the name '$refName' already exists."
  fi
}

ensureDirExists() {
  if [ ! -d "$1" ]; then
    mkdir -p "$1"
  fi
}

dirHasFiles() {
  local existingFiles=$(shopt -s nullglob dotglob; echo "$1"/*)

  if (( ${#existingFiles} )); then
    return 0
  else
    return 1
  fi
}

dirIsEmpty() {
  return $(! dirHasFiles "$1")
}

unwrapString() {
  x="${3#$1}"
  echo "${x%$2}"
}

readRef() {
  unwrapString \" \" $(nix-instantiate --eval -E 'with (import '"$refFilePath"'); '"$2")
}

main "$@"
